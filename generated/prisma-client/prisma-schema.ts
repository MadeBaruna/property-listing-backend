// Code generated by Prisma (prisma@1.34.2). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type Address {
  id: ID!
  street: String!
  city: String!
  country: String!
  longitude: Float!
  latitude: Float!
}

type AddressConnection {
  pageInfo: PageInfo!
  edges: [AddressEdge]!
  aggregate: AggregateAddress!
}

input AddressCreateInput {
  id: ID
  street: String!
  city: String!
  country: String!
  longitude: Float!
  latitude: Float!
}

input AddressCreateOneInput {
  create: AddressCreateInput
  connect: AddressWhereUniqueInput
}

type AddressEdge {
  node: Address!
  cursor: String!
}

enum AddressOrderByInput {
  id_ASC
  id_DESC
  street_ASC
  street_DESC
  city_ASC
  city_DESC
  country_ASC
  country_DESC
  longitude_ASC
  longitude_DESC
  latitude_ASC
  latitude_DESC
}

type AddressPreviousValues {
  id: ID!
  street: String!
  city: String!
  country: String!
  longitude: Float!
  latitude: Float!
}

type AddressSubscriptionPayload {
  mutation: MutationType!
  node: Address
  updatedFields: [String!]
  previousValues: AddressPreviousValues
}

input AddressSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AddressWhereInput
  AND: [AddressSubscriptionWhereInput!]
  OR: [AddressSubscriptionWhereInput!]
  NOT: [AddressSubscriptionWhereInput!]
}

input AddressUpdateDataInput {
  street: String
  city: String
  country: String
  longitude: Float
  latitude: Float
}

input AddressUpdateInput {
  street: String
  city: String
  country: String
  longitude: Float
  latitude: Float
}

input AddressUpdateManyMutationInput {
  street: String
  city: String
  country: String
  longitude: Float
  latitude: Float
}

input AddressUpdateOneRequiredInput {
  create: AddressCreateInput
  update: AddressUpdateDataInput
  upsert: AddressUpsertNestedInput
  connect: AddressWhereUniqueInput
}

input AddressUpsertNestedInput {
  update: AddressUpdateDataInput!
  create: AddressCreateInput!
}

input AddressWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  street: String
  street_not: String
  street_in: [String!]
  street_not_in: [String!]
  street_lt: String
  street_lte: String
  street_gt: String
  street_gte: String
  street_contains: String
  street_not_contains: String
  street_starts_with: String
  street_not_starts_with: String
  street_ends_with: String
  street_not_ends_with: String
  city: String
  city_not: String
  city_in: [String!]
  city_not_in: [String!]
  city_lt: String
  city_lte: String
  city_gt: String
  city_gte: String
  city_contains: String
  city_not_contains: String
  city_starts_with: String
  city_not_starts_with: String
  city_ends_with: String
  city_not_ends_with: String
  country: String
  country_not: String
  country_in: [String!]
  country_not_in: [String!]
  country_lt: String
  country_lte: String
  country_gt: String
  country_gte: String
  country_contains: String
  country_not_contains: String
  country_starts_with: String
  country_not_starts_with: String
  country_ends_with: String
  country_not_ends_with: String
  longitude: Float
  longitude_not: Float
  longitude_in: [Float!]
  longitude_not_in: [Float!]
  longitude_lt: Float
  longitude_lte: Float
  longitude_gt: Float
  longitude_gte: Float
  latitude: Float
  latitude_not: Float
  latitude_in: [Float!]
  latitude_not_in: [Float!]
  latitude_lt: Float
  latitude_lte: Float
  latitude_gt: Float
  latitude_gte: Float
  AND: [AddressWhereInput!]
  OR: [AddressWhereInput!]
  NOT: [AddressWhereInput!]
}

input AddressWhereUniqueInput {
  id: ID
}

type AggregateAddress {
  count: Int!
}

type AggregateFacility {
  count: Int!
}

type AggregateImage {
  count: Int!
}

type AggregatePlace {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Facility {
  id: ID!
  name: String!
}

type FacilityConnection {
  pageInfo: PageInfo!
  edges: [FacilityEdge]!
  aggregate: AggregateFacility!
}

input FacilityCreateInput {
  id: ID
  name: String!
}

input FacilityCreateManyInput {
  create: [FacilityCreateInput!]
  connect: [FacilityWhereUniqueInput!]
}

type FacilityEdge {
  node: Facility!
  cursor: String!
}

enum FacilityOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type FacilityPreviousValues {
  id: ID!
  name: String!
}

input FacilityScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [FacilityScalarWhereInput!]
  OR: [FacilityScalarWhereInput!]
  NOT: [FacilityScalarWhereInput!]
}

type FacilitySubscriptionPayload {
  mutation: MutationType!
  node: Facility
  updatedFields: [String!]
  previousValues: FacilityPreviousValues
}

input FacilitySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FacilityWhereInput
  AND: [FacilitySubscriptionWhereInput!]
  OR: [FacilitySubscriptionWhereInput!]
  NOT: [FacilitySubscriptionWhereInput!]
}

input FacilityUpdateDataInput {
  name: String
}

input FacilityUpdateInput {
  name: String
}

input FacilityUpdateManyDataInput {
  name: String
}

input FacilityUpdateManyInput {
  create: [FacilityCreateInput!]
  update: [FacilityUpdateWithWhereUniqueNestedInput!]
  upsert: [FacilityUpsertWithWhereUniqueNestedInput!]
  delete: [FacilityWhereUniqueInput!]
  connect: [FacilityWhereUniqueInput!]
  set: [FacilityWhereUniqueInput!]
  disconnect: [FacilityWhereUniqueInput!]
  deleteMany: [FacilityScalarWhereInput!]
  updateMany: [FacilityUpdateManyWithWhereNestedInput!]
}

input FacilityUpdateManyMutationInput {
  name: String
}

input FacilityUpdateManyWithWhereNestedInput {
  where: FacilityScalarWhereInput!
  data: FacilityUpdateManyDataInput!
}

input FacilityUpdateWithWhereUniqueNestedInput {
  where: FacilityWhereUniqueInput!
  data: FacilityUpdateDataInput!
}

input FacilityUpsertWithWhereUniqueNestedInput {
  where: FacilityWhereUniqueInput!
  update: FacilityUpdateDataInput!
  create: FacilityCreateInput!
}

input FacilityWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [FacilityWhereInput!]
  OR: [FacilityWhereInput!]
  NOT: [FacilityWhereInput!]
}

input FacilityWhereUniqueInput {
  id: ID
}

type Image {
  id: ID!
  url: String!
  thumbnailUrl: String!
}

type ImageConnection {
  pageInfo: PageInfo!
  edges: [ImageEdge]!
  aggregate: AggregateImage!
}

input ImageCreateInput {
  id: ID
  url: String!
  thumbnailUrl: String!
}

input ImageCreateManyInput {
  create: [ImageCreateInput!]
  connect: [ImageWhereUniqueInput!]
}

type ImageEdge {
  node: Image!
  cursor: String!
}

enum ImageOrderByInput {
  id_ASC
  id_DESC
  url_ASC
  url_DESC
  thumbnailUrl_ASC
  thumbnailUrl_DESC
}

type ImagePreviousValues {
  id: ID!
  url: String!
  thumbnailUrl: String!
}

input ImageScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
  thumbnailUrl: String
  thumbnailUrl_not: String
  thumbnailUrl_in: [String!]
  thumbnailUrl_not_in: [String!]
  thumbnailUrl_lt: String
  thumbnailUrl_lte: String
  thumbnailUrl_gt: String
  thumbnailUrl_gte: String
  thumbnailUrl_contains: String
  thumbnailUrl_not_contains: String
  thumbnailUrl_starts_with: String
  thumbnailUrl_not_starts_with: String
  thumbnailUrl_ends_with: String
  thumbnailUrl_not_ends_with: String
  AND: [ImageScalarWhereInput!]
  OR: [ImageScalarWhereInput!]
  NOT: [ImageScalarWhereInput!]
}

type ImageSubscriptionPayload {
  mutation: MutationType!
  node: Image
  updatedFields: [String!]
  previousValues: ImagePreviousValues
}

input ImageSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ImageWhereInput
  AND: [ImageSubscriptionWhereInput!]
  OR: [ImageSubscriptionWhereInput!]
  NOT: [ImageSubscriptionWhereInput!]
}

input ImageUpdateDataInput {
  url: String
  thumbnailUrl: String
}

input ImageUpdateInput {
  url: String
  thumbnailUrl: String
}

input ImageUpdateManyDataInput {
  url: String
  thumbnailUrl: String
}

input ImageUpdateManyInput {
  create: [ImageCreateInput!]
  update: [ImageUpdateWithWhereUniqueNestedInput!]
  upsert: [ImageUpsertWithWhereUniqueNestedInput!]
  delete: [ImageWhereUniqueInput!]
  connect: [ImageWhereUniqueInput!]
  set: [ImageWhereUniqueInput!]
  disconnect: [ImageWhereUniqueInput!]
  deleteMany: [ImageScalarWhereInput!]
  updateMany: [ImageUpdateManyWithWhereNestedInput!]
}

input ImageUpdateManyMutationInput {
  url: String
  thumbnailUrl: String
}

input ImageUpdateManyWithWhereNestedInput {
  where: ImageScalarWhereInput!
  data: ImageUpdateManyDataInput!
}

input ImageUpdateWithWhereUniqueNestedInput {
  where: ImageWhereUniqueInput!
  data: ImageUpdateDataInput!
}

input ImageUpsertWithWhereUniqueNestedInput {
  where: ImageWhereUniqueInput!
  update: ImageUpdateDataInput!
  create: ImageCreateInput!
}

input ImageWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
  thumbnailUrl: String
  thumbnailUrl_not: String
  thumbnailUrl_in: [String!]
  thumbnailUrl_not_in: [String!]
  thumbnailUrl_lt: String
  thumbnailUrl_lte: String
  thumbnailUrl_gt: String
  thumbnailUrl_gte: String
  thumbnailUrl_contains: String
  thumbnailUrl_not_contains: String
  thumbnailUrl_starts_with: String
  thumbnailUrl_not_starts_with: String
  thumbnailUrl_ends_with: String
  thumbnailUrl_not_ends_with: String
  AND: [ImageWhereInput!]
  OR: [ImageWhereInput!]
  NOT: [ImageWhereInput!]
}

input ImageWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createAddress(data: AddressCreateInput!): Address!
  updateAddress(data: AddressUpdateInput!, where: AddressWhereUniqueInput!): Address
  updateManyAddresses(data: AddressUpdateManyMutationInput!, where: AddressWhereInput): BatchPayload!
  upsertAddress(where: AddressWhereUniqueInput!, create: AddressCreateInput!, update: AddressUpdateInput!): Address!
  deleteAddress(where: AddressWhereUniqueInput!): Address
  deleteManyAddresses(where: AddressWhereInput): BatchPayload!
  createFacility(data: FacilityCreateInput!): Facility!
  updateFacility(data: FacilityUpdateInput!, where: FacilityWhereUniqueInput!): Facility
  updateManyFacilities(data: FacilityUpdateManyMutationInput!, where: FacilityWhereInput): BatchPayload!
  upsertFacility(where: FacilityWhereUniqueInput!, create: FacilityCreateInput!, update: FacilityUpdateInput!): Facility!
  deleteFacility(where: FacilityWhereUniqueInput!): Facility
  deleteManyFacilities(where: FacilityWhereInput): BatchPayload!
  createImage(data: ImageCreateInput!): Image!
  updateImage(data: ImageUpdateInput!, where: ImageWhereUniqueInput!): Image
  updateManyImages(data: ImageUpdateManyMutationInput!, where: ImageWhereInput): BatchPayload!
  upsertImage(where: ImageWhereUniqueInput!, create: ImageCreateInput!, update: ImageUpdateInput!): Image!
  deleteImage(where: ImageWhereUniqueInput!): Image
  deleteManyImages(where: ImageWhereInput): BatchPayload!
  createPlace(data: PlaceCreateInput!): Place!
  updatePlace(data: PlaceUpdateInput!, where: PlaceWhereUniqueInput!): Place
  updateManyPlaces(data: PlaceUpdateManyMutationInput!, where: PlaceWhereInput): BatchPayload!
  upsertPlace(where: PlaceWhereUniqueInput!, create: PlaceCreateInput!, update: PlaceUpdateInput!): Place!
  deletePlace(where: PlaceWhereUniqueInput!): Place
  deleteManyPlaces(where: PlaceWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Place {
  id: ID!
  name: String!
  description: String!
  facilities(where: FacilityWhereInput, orderBy: FacilityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Facility!]
  type: PlaceType!
  images(where: ImageWhereInput, orderBy: ImageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Image!]
  address: Address!
}

type PlaceConnection {
  pageInfo: PageInfo!
  edges: [PlaceEdge]!
  aggregate: AggregatePlace!
}

input PlaceCreateInput {
  id: ID
  name: String!
  description: String!
  facilities: FacilityCreateManyInput
  type: PlaceType!
  images: ImageCreateManyInput
  address: AddressCreateOneInput!
}

type PlaceEdge {
  node: Place!
  cursor: String!
}

enum PlaceOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  type_ASC
  type_DESC
}

type PlacePreviousValues {
  id: ID!
  name: String!
  description: String!
  type: PlaceType!
}

type PlaceSubscriptionPayload {
  mutation: MutationType!
  node: Place
  updatedFields: [String!]
  previousValues: PlacePreviousValues
}

input PlaceSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PlaceWhereInput
  AND: [PlaceSubscriptionWhereInput!]
  OR: [PlaceSubscriptionWhereInput!]
  NOT: [PlaceSubscriptionWhereInput!]
}

enum PlaceType {
  OFFICE
  APARTMENT
}

input PlaceUpdateInput {
  name: String
  description: String
  facilities: FacilityUpdateManyInput
  type: PlaceType
  images: ImageUpdateManyInput
  address: AddressUpdateOneRequiredInput
}

input PlaceUpdateManyMutationInput {
  name: String
  description: String
  type: PlaceType
}

input PlaceWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  facilities_every: FacilityWhereInput
  facilities_some: FacilityWhereInput
  facilities_none: FacilityWhereInput
  type: PlaceType
  type_not: PlaceType
  type_in: [PlaceType!]
  type_not_in: [PlaceType!]
  images_every: ImageWhereInput
  images_some: ImageWhereInput
  images_none: ImageWhereInput
  address: AddressWhereInput
  AND: [PlaceWhereInput!]
  OR: [PlaceWhereInput!]
  NOT: [PlaceWhereInput!]
}

input PlaceWhereUniqueInput {
  id: ID
}

type Query {
  address(where: AddressWhereUniqueInput!): Address
  addresses(where: AddressWhereInput, orderBy: AddressOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Address]!
  addressesConnection(where: AddressWhereInput, orderBy: AddressOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AddressConnection!
  facility(where: FacilityWhereUniqueInput!): Facility
  facilities(where: FacilityWhereInput, orderBy: FacilityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Facility]!
  facilitiesConnection(where: FacilityWhereInput, orderBy: FacilityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FacilityConnection!
  image(where: ImageWhereUniqueInput!): Image
  images(where: ImageWhereInput, orderBy: ImageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Image]!
  imagesConnection(where: ImageWhereInput, orderBy: ImageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ImageConnection!
  place(where: PlaceWhereUniqueInput!): Place
  places(where: PlaceWhereInput, orderBy: PlaceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Place]!
  placesConnection(where: PlaceWhereInput, orderBy: PlaceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PlaceConnection!
  node(id: ID!): Node
}

type Subscription {
  address(where: AddressSubscriptionWhereInput): AddressSubscriptionPayload
  facility(where: FacilitySubscriptionWhereInput): FacilitySubscriptionPayload
  image(where: ImageSubscriptionWhereInput): ImageSubscriptionPayload
  place(where: PlaceSubscriptionWhereInput): PlaceSubscriptionPayload
}
`